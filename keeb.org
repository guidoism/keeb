
First we define what we mean by single characters in our own format
(char space+ definition newline). Do this in a code space.

then we define our keymaps in a nice grid using combinations of
those single characters seperated by whitespace.

Next we define our keyboard as a sequence of columns and rows
or just all of the keys and define how they relate to the grid
we used in our keymaps.

Finally we write the firmware that runs on the keyboard. It should be
specific to our keyboard. We are doing this "inside-out" as compared
to most software these days -- We are writing the firmware ourselves
using help from utility routines to make the code idiomatic. This is
contrasted with the more common approach of providing a framework or
library that you use by way of configuration.

* How to use

Run M-x org-babel-tangle to generate the =main.py= and =kb.py= files.

We will also need to copy those files to the keyboard. Because circuit
python will reload stuff immediately it's best to not be in the middle
of a keystroke while this is happening so we put a delay between
starting the process of keyboard upload and actually doing the copy.

** Getting the stuff onto the board

- [ ] Confirm that keyboard file is valid before copying over

#+begin_src sh
sleep 2
cp output/*.py /Volumes/KEEB-1/
echo "Done"
#+end_src

#+RESULTS:
: Done


* Single-character definitions


https://www.emacswiki.org/emacs/TabStopList

#+name: conversion
#+begin_example
char   qmk       kmk      zmk
␣      KC_SPC    KC.SPC   ?
!      KC_EXLM   KC.EXLM  ?
"      KC_DQUO   KC.DQUO  ?
#      KC_HASH   KC.HASH
$      KC_DLR    KC.DLR   ?
%      KC_PERC   KC.PERC  ?
&      KC_AMPR   KC.AMPR  ?
'      KC_QUOT   KC.QUOT
(      KC_LPRN   KC.LPRN  ?
)      KC_RPRN   KC.RPRN  ?
 *     KC_PAST   KC.PAST
+      KC_PLUS   KC.PLUS  ?
,      KC_COMMA  KC.COMMA
-      KC_MINUS  KC.MINUS
.      KC_DOT    KC.DOT
/      KC_SLASH  KC.SLASH
0      KC_0      KC.N0
1      KC_1      KC.N1
2      KC_2      KC.N2
3      KC_3      KC.N3
4      KC_4      KC.N4
5      KC_5      KC.N5
6      KC_6      KC.N6
7      KC_7      KC.N7
8      KC_8      KC.N8
9      KC_9      KC.N9
:      KC_COLN   KC.COLN  ?
;      KC_SCLN   KC.SCLN
<      KC_LT     KC.LABK    ?
=      KC_EQL    KC.EQL
>      KC_GT     KC.RABK    ?
?      KC_QUES   KC.QUES  ?
@      KC_AT     KC.AT
A      S(A)      KC.LSFT(A) 
B      S(B)      KC.LSFT(B)
C      S(C)      KC.LSFT(C)
D      S(D)      KC.LSFT(D)
E      S(E)      KC.LSFT(E)
F      S(F)      KC.LSFT(F)
G      S(G)      KC.LSFT(G)
H      S(H)      KC.LSFT(H)
I      S(I)      KC.LSFT(I)
J      S(J)      KC.LSFT(J)
K      S(K)      KC.LSFT(K)
L      S(L)      KC.LSFT(L)
M      S(M)      KC.LSFT(M)
N      S(N)      KC.LSFT(N)
O      S(O)      KC.LSFT(O)
P      S(P)      KC.LSFT(P)
Q      S(Q)      KC.LSFT(Q)
R      S(R)      KC.LSFT(R)
S      S(S)      KC.LSFT(S)
T      S(T)      KC.LSFT(T)
U      S(U)      KC.LSFT(U)
V      S(V)      KC.LSFT(V)
W      S(W)      KC.LSFT(W)
X      S(X)      KC.LSFT(X)
Y      S(Y)      KC.LSFT(Y)
Z      S(Z)      KC.LSFT(Z)
[      KC_LBRC   KC.LBRC
\      KC_BSLS   KC.BSLS
]      KC_RBRC   KC.RBRC
^      KC_CIRC   KC.CIRC
_      KC_UNDS   KC.UNDS
`      KC_GRV    KC.GRV
a      KC_A      KC.A
b      KC_B      KC.B
c      KC_C      KC.C
d      KC_D      KC.D
e      KC_E      KC.E
f      KC_F      KC.F
g      KC_G      KC.G
h      KC_H      KC.H
i      KC_I      KC.I
j      KC_J      KC.J
k      KC_K      KC.K
l      KC_L      KC.L
m      KC_M      KC.M
n      KC_N      KC.N
o      KC_O      KC.O
p      KC_P      KC.P
q      KC_Q      KC.Q
r      KC_R      KC.R
s      KC_S      KC.S
t      KC_T      KC.T
u      KC_U      KC.U
v      KC_V      KC.V
w      KC_W      KC.W
x      KC_X      KC.X
y      KC_Y      KC.Y
z      KC_Z      KC.Z
{      KC_LCBR   KC.LCBR
|      KC_PIPE   KC.PIPE
}      KC_RCBR   KC.RCBR
~      KC_TILDE  KC.TILDE

◌      KC_NO     KC.NO
◉      KC_NO     KC.NO
:;     COLON_SEMI COLON_SEMI


⌃       KC_LCTL   KC.LCTL
CTL     KC_LCTL   KC.LCTL
⇧       KC_LSFT   KC.LSFT
SFT     KC_LSFT   KC.LSFT
⌥      KC_LOPT   KC.LOPT
OPT     KC_LOPT   KC.LOPT
⌘       KC_LCMD   KC.LCMD
CMD     KC_LCMD   KC.LCMD

C-M     KC_LCTL(KC_LCMD) KC.LCTL(KC.LCMD)


⇪      CAPS_WORD   CAPS_WORD   
CAPS   CAPS_WORD   CAPS_WORD   

↵       KC_ENT   KC.ENT
RET     KC_ENT   KC.ENT
⎋      KC_ESC   KC.ESC
ESC     KC_ESC   KC.ESC
⌫      KC_BSPC   KC.BSPC
BS      KC_BSPC   KC.BSPC
⇥       KC_TAB   KC.TAB
TAB     KC_TAB   KC.TAB

HME  KC_HOME   KC.HOME
END  KC_END   KC.END
P↑   KC_PGUP   KC.PGUP
P↓   KC_PGDN   KC.PGDN
→    KC_RIGHT   KC.RIGHT
←    KC_LEFT   KC.LEFT
↓    KC_DOWN   KC.DOWN
↑    KC_UP   KC.UP

M₀   MO(0)   KC.MO(0)
M₁   MO(1)   KC.MO(1)
M₂   MO(2)   KC.MO(2)
M₃   MO(3)   KC.MO(3)
M₄   MO(4)   KC.MO(4)
M₅   MO(5)   KC.MO(5)
M₆   MO(6)   KC.MO(6)
M₇   MO(7)   KC.MO(7)
M₈   MO(8)   KC.MO(8)
M₉   MO(9)   KC.MO(9)

M0   MO(0)   KC.MO(0)
M1   MO(1)   KC.MO(1)
M2   MO(2)   KC.MO(2)
M3   MO(3)   KC.MO(3)
M4   MO(4)   KC.MO(4)
M5   MO(5)   KC.MO(5)
M6   MO(6)   KC.MO(6)
M7   MO(7)   KC.MO(7)
M8   MO(8)   KC.MO(8)
M9   MO(9)   KC.MO(9)

F1     KC_F1     KC.F1
F2     KC_F2     KC.F2
F3     KC_F3     KC.F3
F4     KC_F4     KC.F4
F5     KC_F5     KC.F5
F6     KC_F6     KC.F6
F7     KC_F7     KC.F7
F8     KC_F8     KC.F8
F9     KC_F9     KC.F9
F10    KC_F10    KC.F10
F11    KC_F11    KC.F11
F12    KC_F12    KC.F12

⌃z     LCMD(KC_Z) KC.LCMD(KC.Z)
⌃x     LCMD(KC_X) KC.LCMD(KC.X)
⌃c     LCMD(KC_C) KC.LCMD(KC.C)
⌃v     LCMD(KC_V) KC.LCMD(KC.V)

W←     LCMD(KC_B) KC.LCMD(KC.B)
W→     LCMD(KC_F) KC.LCMD(KC.F)
λ←     TDB        KC.LCTL(KC.LCMD(KC.B))
λ→     TDB        KC.LCTL(KC.LCMD(KC.F))
¶←     TDB        KC.LCMD(KC.LCBR)
¶→     TDB        KC.LCMD(KC.RCBR)
S←     TDB        KC.LCMD(KC.A)
S→     TDB        KC.LCMD(KC.E)

BEG    LCMD(KC_M) KC.LCMD(KC.M)

CYC    CYC CYC
Bu0    Bu0 Bu0
Bu1    Bu1 Bu1
Bu2    Bu2 Bu2
Bu3    Bu3 Bu3
Bu4    Bu4 Bu4

∫E     TBD KC.MEH(KC.E)
∫S     TBD KC.MEH(KC.S)
∫D     TBD KC.MEH(KC.D)
∫C     TBD KC.MEH(KC.C)
∫P     TBD KC.MEH(KC.P)


#+end_example




* Old Keymaps

#+name: planck_20221012
#+begin_example
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ESC  OPT  CMD   M1   M6   ␣    M2   ◌    ◌    ◌    CS

~    !    @    #    $    %    ^    &    *    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    _    +    "    '    |
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    1    2    3    4    5    6    7    8    9    0    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑   P↓    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌   OPT  CMD   M4   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    7    8    9    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    4    5    6    ◌    ◌
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_example

It's a pain in the ass to change a keymap all at once so I'm going to
attempt to do it a bit at a time. My strategy will be something like
this:

- [X] Move 0 in the numpad layer off of the mod row in anticipation of losing those keys
- [X] Move the movement layer to the left space button, need to still consider that we use
      that to get to the numpad row so keep it working like before too
- [X] Make a beep when I use the palm key for movement
- [X] Since there's not much in the current symbol layer, move as many symbols as possible
      to the numpad layer and move the numpad layer over to M1. We will need to relocate:
      &    *    _    +    "
      And we might as well move those over to the symbol layer as soon as possible
      
At this point what we end up with is _ still being symmetrical with - but it's LWR-F
instead of LWR-J and in some ways this maintains the symmetry in that both keys use
the home index key above the layer key.

The two quotes are also symmetrical in that the single quote uses the right pinky
and the double uses the right pinky on the same layer.

We add another period to the numpad layer so we can do a single roll of N-B to do '0.'

#+name: planck_20221014
#+begin_example
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ⍉ESC OPT  CMD   M1   M6   ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^   ⍉&   ⍉*    ◌    ◌    ◌
◌    "    &    *    _    ◌    +   ⍉_   ⍉+   ⍉"    '    |
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    1    2    3    4    5    6    7    8    9    0    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ⍉↑   P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ⍉←   ⍉↓   ⍉→   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌   OPT  CMD   M4   ◌    ◌    ◌    ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    7    8    9    ◌    ◌
◌    "    &    *    _    ◌    +    4    5    6    '    |
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    /    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌   OPT  CMD   M4   ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_example

Now that we've somwhat gotten used to the new movement
layer button and the moved symbols we can turn off the
old stuff and go ahead and remove the old numbers from
the old number layer.

- [X] Move num layer to LWR
- [X] Put shift on thumb
- [X] Move ESC to another layer
- [ ] There should be a paste button on the move layer (C-y)
- [ ] Searching is part of moving in emacs and should be on move layer
- [X] Shift-: should be ;
- [ ] Find something better for the place where ; is
- [X] Put start/end macro buttons on move

#+name: planck_20221018
#+begin_example
⇥    q    w    e    r    t    y    u    i    o    p    BS 
⌃    a    s    d    f    g    h    j    k    l    :;   RET
⇧    z    x    c    v    b    n    m    ,    .    /    ◌
◌    ◌   OPT  CMD   M1   M3   ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    7    8    9    ◌    ◌
◌    "    &    *    _    ◌    +    4    5    6    '    |
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    /    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

ESC  ◌    ◌    F3   F4   ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ⌃z   ⌃x   ⌃c   ⌃v   ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌   OPT  CMD   M1   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌   OPT  CMD   M4   ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_example


* Keymaps

Now that we have the old number and symbols layers gone,
let's see what else we can clean up

- [X] Make it easier to switch between buffers in emacs
- [ ] Find a better way to shift, probably one-shot
- [ ] Add caps word (maybe to the function key layer?)
- [ ] Figure out what I'm going to do with the mostly empty M2
- [ ] Make use of shift-, and shift-.
- [ ] Use , and . as modifiers or layer changes if held down
- [ ] Use Combo of the far pinkies (control and return) for something

#+name: planck_20221020
#+begin_example
TAB   q    w    e    r    t        y    u    i    o    p   BS 
CTL   a    s    d    f    g        h    j    k    l    :;  RET
SFT   z    x    c    v    b        n    m    ,    .    /   ◌
 ◌    ◌   OPT  CMD  M1   M3        ␣   M2   ◌    ◌    ◌    ◌

 ~    !    @    #    $    %        ^    7    8    9    ◌    ◌
 ◌    "    &    *    _    ◌        +    4    5    6    '    |
 ◌    ◌    ◌    ◌    ◌    .        0    1    2    3    /    ◌
 ◌    ◌   OPT  CMD   ◉    ◌        ◌   M5    ◌    ◌    ◌    ◌

 `    ◌    ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌   BS
 ◌    [    ]    (    )    ◌        ◌    -    =    ◌    ◌    \
 ◌    <    >    {    }    ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌   OPT  CMD  M4    ◌        ◌    ◉    ◌    ◌    ◌    ◌

ESC  λ←   λ→   ¶←   ¶→    ◌        ◌   P↑    ↑   P↓    ◌    ◌
 ◌   S←   S→   W←   W→   BEG       ◌    ←    ↓    →   CYC   ◌
 ◌   ⌃z   ⌃x   ⌃c   ⌃v    ◌        ◌   HME   ◌   END   ◌    ◌
 ◌    ◌   OPT  CMD  M1    ◉        ◌    ◌    ◌    ◌    ◌    ◌

 ◌    F1   F2   F3   F4   F5       F6   F7   F8   F9   F10   ◌
 ◌    ∫C   ∫D   ∫S   ∫E   ∫P       Bu0  Bu1  Bu2  Bu3  Bu4   ◌
 ◌    ◌    ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌   OPT  CMD   ◉    ◌        ◌    ◉    ◌    ◌    ◌    ◌

 ◌    ◌    ◌    ◌    ◌    a        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌    ◌    ◌    ◌    b        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌    ◌    ◌    ◌    c        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌   OPT  CMD   ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌

#+end_example


*** Emacs shortcuts

This is where we make keymap-like definitions that allow us
to see emacs shortcuts on our layer status viewer when
pressing down control, meta, etc.

NOTE: Seems like three letter isn't quite enough to be meaningful.

#+name: emacs_keymap
#+begin_example
CONTROL
 ◌    ◌   EoL   ◌   BSe   ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌   BoL  FSe   ◌    ◌   ABT      HLP   ◌    ◌   CTR   ◌    ◌
 ◌    ◌    ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌    ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌

COMMAND
 ◌    ◌   EoS   ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌   BoS   ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌    ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌
 ◌    ◌    ◌    ◌    ◌    ◌        ◌    ◌    ◌    ◌    ◌    ◌
#+end_example



*** Old fork not sure about
#+name: planck (mark ii)
#+begin_src keymap
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ESC  OPT  CMD   M1   M3   ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    7    8    9    ◌    ◌
◌    "    &    *    _    ◌    +    4    5    6    '    |
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    1    2    3    4    5    6    7    8    9    0    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌    ◌    ◌    M1   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_src

- [ ] At this point we pretty much never use the number row on M2 so we migth as well remove
      those numbers. The right thumb now is pretty much only used for the symmetrical brackets
      and the:  -   =   \

#+name: planck (mark iii)
#+begin_example
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ESC  OPT  CMD   M1   M3   ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    7    8    9    ◌    ◌
◌    "    &    *    _    ◌    +    4    5    6    '    |
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌    ◌    ◌    M1   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_example


* Debouncing

Simple de-bouncing (take last three and confirm they are all equal)

The assumption is that the wait time between each period in
history is long enough for debouncing. If it isn't then we can
increase the maxlen of the history deque.

#+begin_src python
history = collections.Deque(maxlen=3)
def debounce(keys):
    history.append(keys)
    return [a == b == c for a, b, c in zip(*history)]
#+end_src



#+begin_src python
keys = bitstring()
for w in writers:
    w.value = True
    for r in readers:
        keys.append(r.value())
    w.value = False

# The keys that are currently on    
on = debounce(keys)

switched_off = last - on
switched_on = on - last
last = on



#+end_src

We make decisions as to what is happening based on discrete snapshots
in time of the global state. It can be thought of as a matrix where
the y axis is time and the x axis is the set of keys.

.▪.▪...▪.....
.▪....▪▪.....
.▪....▪▪.....
.▪....▪▪.....
......▪......
......▪......

Then our job is just pattern matching over that matrix, finding the
match with the highest priority.

When we use a set of keys during that window we also take claim to
them for that time period so other potential patterns don't match
if they aren't supposed to.

*** Normal Keypress

A keypress is a sequence of ones followed by a zero.


*** Combos

A combo is when two keys are pressed the same time. But we can be
loose with our definition of "same time", so in we can allow the
key-downs to start within 5 ticks and allow the key-ups to end at
any time after that. And we can have different behaviors depending
on which key-up event happens first.

Actually if we transpose the matrix to be time on the x and keys on
the y then I think we can use regexes really easily to do the
matching, yes? Actually, since it's just boolean values it's now
easy to use a bitstring for each key. If we store 64 values in our
time window, then a single 64 bit word can be compared with another
word. 64 events at 5ms per event is 320ms which I think is probably
good enough.

QMK uses 50ms as the default combo term, which would be 10 quanta in
our system. For example if Key A starts at time 0 and Key B starts at
time 8 and both of them are pressed for an additional 4 quanta then
we will match this as a combo event for the two of them. To prevent
further matches we mask out the two keys during this time period.

We need to also decide whether to fire the key event when the match
happens or whether we wait until one or both of the keys are lifted.

High-level overview:

1. Get the set of keys that have at least one down event recorded
   (i.e., they aren't just zeros).

2. Loop over each of the configured combos sorted in order of
   most keys in the combo first.

3. Determine if the keys overlap for the minimum amount. If the
   minimum amount is 10 quanta then we want to make sure there is a
   sequence of 10 on bits -- 11 1111 1111 (1024) -- in common. Can can
   shift, mask, and AND to determine if this is true.

4. TODO: Look for a series of ones in front of one of them that extends
   for too long?


* Utility Routines

#+begin_src python
def bits(bs):
    """Converts the handy '▪.' bitstring format into a list of 0s and 1s.    
    """
    B = {'▪': 1, '.': 0}
    return [B[b] for b in bs]


def key_press(key, context, action):
    """Returns True if the key in the context was pressed.

    Side-effects include clearing out this event from the context
    and firing the provided action.

    >>> c = [bits('...▪▪.', '....▪.')]
    >>> c
    [[0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0]]
    >>> key_press(0, c, lambda k: print(f'Pressed {k}'))
    Pressed 0
    >>> c
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0]]
    """
    pass

def key_down(key, context):
    """Returns True if the key in the context is being current held down.

    No side-effects.
    """
    pass

#+end_src


* Generate KMK firmware keymap list

#+name: generate_kmk_keymap
#+begin_src python :var src=planck_20221020 :var conversion_in=conversion :results value
import json
json.dump(src.split('\n\n'), open('output/layers.json', 'w'))

def chunk(iterable, n):
    args = [iter(iterable)] * n
    return zip(*args)

import re, json
conversion = {}
for s in conversion_in.split('\n')[1:]:
    if s:
        k, *vals = re.findall(r'\S+', s)
        conversion[k] = vals[1]

### GUIDO TeX output        
### GUIDO TeX output        
escape = {
    '&': '\\&', '%': '\\%', '$': '\\$', '#': '\\#', '_': '\\_', '{': '$\\{$', '}': '$\\}$',
    '~': '\\char`\\~', '^': '\\char`\\^', '\\': 'poop',
    '⇥': 'TAB', '◌': '' # '\\bigcirc',
}
import string
def key(k):
    if k in string.ascii_lowercase:
        k = k.upper()
    return escape.get(k, k)
layer = lambda l: [key(k) for k in l.split()]

def weave(i, layer):
    s = []
    for row in chunk(layer, 12):
        s.append(' & '.join(row) + ' \\cr')
    return '\n'.join(s) + '\\cr'

tex = '\n'.join([weave(i, layer(l)) for i, l in enumerate(src.split('\n\n'))])
with open('output/pretty.tex', 'w') as f:
    f.write('\\tt \halign{\n')
    f.write('&'.join(['\\hfil\\quad#\\quad\\hfil']*12))
    f.write('\\cr\n')
    f.write(tex)
    f.write('}\n\\bye')
### GUIDO TeX output        
### GUIDO TeX output        

key = lambda k: f'D({conversion[k[1:]]})' if k[0] == '⍉' else conversion[k]
layer = lambda l: [key(k) for k in l.split()]

def tangle(i, layer):
    s = ['[', f'# Layer {i}']
    for row in chunk(layer, 12):
        s.append(', '.join(row) + ',')
    s.append('],')
    return '\n'.join(s)

return '\n'.join([tangle(i, layer(l)) for i, l in enumerate(src.split('\n\n'))])
#+end_src

#+RESULTS: generate_kmk_keymap
#+begin_example
[
# Layer 0
KC.TAB, KC.Q, KC.W, KC.E, KC.R, KC.T, KC.Y, KC.U, KC.I, KC.O, KC.P, KC.BSPC,
KC.LCTL, KC.A, KC.S, KC.D, KC.F, KC.G, KC.H, KC.J, KC.K, KC.L, COLON_SEMI, KC.ENT,
KC.LSFT, KC.Z, KC.X, KC.C, KC.V, KC.B, KC.N, KC.M, KC.COMMA, KC.DOT, KC.SLASH, KC.NO,
KC.NO, KC.NO, KC.LOPT, KC.LCMD, KC.MO(1), KC.MO(3), KC.SPC, KC.MO(2), KC.NO, KC.NO, KC.NO, KC.NO,
],
[
# Layer 1
KC.TILDE, KC.EXLM, KC.AT, KC.HASH, KC.DLR, KC.PERC, KC.CIRC, KC.N7, KC.N8, KC.N9, KC.NO, KC.NO,
KC.NO, KC.DQUO, KC.AMPR, KC.PAST, KC.UNDS, KC.NO, KC.PLUS, KC.N4, KC.N5, KC.N6, KC.QUOT, KC.PIPE,
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.DOT, KC.N0, KC.N1, KC.N2, KC.N3, KC.SLASH, KC.NO,
KC.NO, KC.NO, KC.LOPT, KC.LCMD, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
],
[
# Layer 2
KC.GRV, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.BSPC,
KC.NO, KC.LBRC, KC.RBRC, KC.LPRN, KC.RPRN, KC.NO, KC.NO, KC.MINUS, KC.EQL, KC.NO, KC.NO, KC.BSLS,
KC.NO, KC.LABK, KC.RABK, KC.LCBR, KC.RCBR, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
KC.NO, KC.NO, KC.LOPT, KC.LCMD, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
],
[
# Layer 3
KC.ESC, KC.NO, KC.NO, KC.F3, KC.F4, KC.NO, KC.NO, KC.PGUP, KC.UP, KC.PGDN, KC.NO, KC.NO,
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.LEFT, KC.DOWN, KC.RIGHT, KC.NO, KC.NO,
KC.NO, KC.LCMD(KC.Z), KC.LCMD(KC.X), KC.LCMD(KC.C), KC.LCMD(KC.V), KC.NO, KC.NO, KC.HOME, KC.NO, KC.END, KC.NO, KC.NO,
KC.NO, KC.NO, KC.LOPT, KC.LCMD, KC.MO(1), KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
],
[
# Layer 4
KC.NO, KC.F1, KC.F2, KC.F3, KC.F4, KC.F5, KC.F6, KC.F7, KC.F8, KC.F9, KC.F10, KC.NO,
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
KC.NO, KC.NO, KC.LOPT, KC.LCMD, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
],
[
# Layer 5
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
KC.NO, KC.NO, KC.LOPT, KC.LCMD, KC.MO(4), KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO, KC.NO,
],
#+end_example


* KMK Keyboard definition (no keymap)

~#+name: kb.py
#+begin_src python :tangle output/kb.py
import board

from kmk.kmk_keyboard import KMKKeyboard as _KMKKeyboard
from kmk.scanners import DiodeOrientation

class KMKKeyboard(_KMKKeyboard):
    col_pins = (
        board.GP6,  board.GP7,  board.GP8,  board.GP9,
        board.GP10, board.GP11, board.GP12, board.GP13,
        board.GP21, board.GP20, board.GP19, board.GP18,
    )

    row_pins = (board.GP2, board.GP3, board.GP4, board.GP5)
    
    diode_orientation = DiodeOrientation.COL2ROW
#+end_src

#+name: main.py
#+begin_src python :tangle output/main.py :noweb yes
import board
from kb import KMKKeyboard
from kmk.handlers.sequences import simple_key_sequence
from kmk.keys import KC, make_key
from kmk.modules.layers import Layers
from kmk.modules.modtap import ModTap

D = lambda k: simple_key_sequence((k, KC.F12))
CYC = simple_key_sequence((KC.LCTL(KC.X), KC.O))
Bu0 = simple_key_sequence((KC.LCTL(KC.X), KC.N0))
Bu1 = simple_key_sequence((KC.LCTL(KC.X), KC.N1))
Bu2 = simple_key_sequence((KC.LCTL(KC.X), KC.N2))
Bu3 = simple_key_sequence((KC.LCTL(KC.X), KC.N3))
Bu4 = simple_key_sequence((KC.LCTL(KC.X), KC.N4))

keyboard = KMKKeyboard()
keyboard.debug_enabled = False
keyboard.modules.append(Layers())
keyboard.modules.append(ModTap())

<<layer_change_extension>>
<<shifted_colon_semicolon>>

keyboard.keymap = [
    <<generate_kmk_keymap()>>
]

if __name__ == '__main__':
    keyboard.go()
#+end_src

*** Layer Status Viewer

#+name: status.py
#+begin_src python :tangle output/status.py :results value pp
import json, subprocess, serial, re, rich, rich.console, os
updated = os.stat('layers.json').st_mtime
layers = json.load(open('layers.json'))

p = subprocess.run(['/Users/guido/miniforge3/bin/discotool', 'json'], capture_output=True)
devs = json.loads(p.stdout)
vol = lambda d: {v['name'] for v in d['volumes']}
path = [d['ports'][0]['dev'] for d in devs if 'KEEB-1' in vol(d)][0]
ser = serial.Serial(path)

con = rich.console.Console()
while s := ser.readline():
    if m := re.match(r'Layer: (\d+)', s.decode()):
        n = int(m.group(1))
        con.clear()
        con.print(layers[n].replace('◌', '[dim]◌[/dim]').replace('◉', '[dim]◉[/dim]'))

        if os.stat('layers.json').st_mtime > updated:
            updated = os.stat('layers.json').st_mtime
            layers = json.load(open('layers.json'))

#+end_src

#+RESULTS: status.py

*** Layer Change Extension

#+name: layer_change_extension
#+begin_src python

from kmk.extensions import Extension

class LayerChangeKeyEvent(Extension):
    def __init__(self):
        self._prevLayers = 0

    def on_runtime_enable(self, sandbox):
        return

    def on_runtime_disable(self, sandbox):
        return

    def during_bootup(self, board):
        return

    def before_matrix_scan(self, sandbox):
        if sandbox.active_layers[0] != self._prevLayers:
            self._prevLayers = sandbox.active_layers[0]
            try:
                n = sandbox.active_layers[0]
                print(f'Layer: {n}')
                #if n == 0:
                #    keyboard.tap_key(KC.MEH(KC.N0))
                #elif n == 1:
                #    keyboard.tap_key(KC.MEH(KC.N1))
                #elif n == 2:
                #    keyboard.tap_key(KC.MEH(KC.N2))
                #elif n == 3:
                #    keyboard.tap_key(KC.MEH(KC.N3))
                #elif n == 4:
                #    keyboard.tap_key(KC.MEH(KC.N4))
                #elif n == 5:
                #    keyboard.tap_key(KC.MEH(KC.N5))
                #elif n == 6:
                #    keyboard.tap_key(KC.MEH(KC.N6))
            except e:
                print(e)
        return

    def after_matrix_scan(self, sandbox):
        return

    def before_hid_send(self, sandbox):
        return

    def after_hid_send(self, sandbox):
        return

    def on_powersave_enable(self, sandbox):
        return

    def on_powersave_disable(self, sandbox):
        return

layer_change_extension = LayerChangeKeyEvent()    
keyboard.extensions.append(layer_change_extension)
    
#+end_src

*** Shifted Colon/Semicolon

#+name: shifted_colon_semicolon
#+begin_src python
discarded_shift = []

def colon_pressed(key, keyboard, KC, *args, **kwargs):
    TRIGGERS = {KC.LSHIFT, KC.RSHIFT}

    # We just need to toggle shift
    if TRIGGERS.intersection(keyboard.keys_pressed):
        if KC.LSHIFT in keyboard.keys_pressed:
            keyboard.keys_pressed.remove(KC.LSHIFT)
            discarded_shift.append(KC.LSHIFT)
        if KC.RSHIFT in keyboard.keys_pressed:
            keyboard.keys_pressed.remove(KC.RSHIFT)
            discarded_shift.append(KC.RSHIFT)
        keyboard.keys_pressed.discard(KC.COLON)
        keyboard.keys_pressed.add(KC.SEMICOLON)
        keyboard.hid_pending = True
        return keyboard

    keyboard.keys_pressed.add(KC.COLON)
    keyboard.hid_pending = True

    return keyboard

def colon_released(key, keyboard, KC, *args, **kwargs):
    keyboard.keys_pressed.discard(KC.SEMICOLON)
    keyboard.keys_pressed.discard(KC.COLON)
    while discarded_shift:
        keyboard.keys_pressed.add(discarded_shift.pop())
    keyboard.hid_pending = True
    return keyboard

COLON_SEMI = make_key(None, ('COLON_SEMI',),
                      on_press=colon_pressed,
                      on_release=colon_released,
                      )
#+end_src


* Formal definitions and finite automata

** Keypress

Actions:
- Press A

States:

1. Press
2. Release

** Momentary Layer

This is essentially the way shift works. We have two buttons, 'a' and
'shift'.

key-press a
key-release a
event 'a'

key-press shift
key-press a
key-release a
event 'A'
key-release shift

key-press shift
key-release shift
key-press a
key-release a
event 'a'

The latter is what happens during a normal shift operation but we can
subtly tweak this sequence to improve our typing experience. For
example we can fire off a timer when shift is released and continue to
maintain the 'shifted' state for a period of a few seconds to make it
easier to use a modifier from another layer. It also allows us to
allow for a little slop when normally people are typing quickly. Even
if the shifted state only stayed around for hundreds of ms it would
probably still improve typing accuracy.

key-press shift
key-release shift
timer 200ms maintain shifted state until it fires
key-press a
key-release a
event 'A'
timer cancelled at last event or after timer fires




First we define what we mean by single characters in our own format
(char space+ definition newline). Do this in a code space.

Then we define our keymaps in a nice grid using combinations of
those single characters seperated by whitespace.

Next we define our keyboard as a sequence of columns and rows
or just all of the keys and define how they relate to the grid
we used in our keymaps.

Finally we write the firmware that runs on the keyboard. It should be
specific to our keyboard. We are doing this "inside-out" as compared
to most software these days -- We are writing the firmware ourselves
using help from utility routines to make the code idiomatic. This is
contrasted with the more common approach of providing a framework or
library that you use by way of configuration.

* How to use

Run M-x org-babel-tangle


* Single-character definitions


https://www.emacswiki.org/emacs/TabStopList

#+name: conversion
#+begin_example
char   qmk       kmk      zmk
␣      KC_SPC    KC.SPC   ?
!      KC_EXLM   KC.EXLM  ?
"      KC_DQUO   KC.DQUO  ?
#      KC_HASH   KC.HASH
$      KC_DLR    KC.DLR   ?
%      KC_PERC   KC.PERC  ?
&      KC_AMPR   KC.AMPR  ?
'      KC_QUOT   KC.QUOT
(      KC_LPRN   KC.LPRN  ?
)      KC_RPRN   KC.RPRN  ?
 *     KC_PAST   KC.PAST
+      KC_PLUS   KC.PLUS  ?
,      KC_COMMA  KC.COMMA
-      KC_MINUS  KC.MINUS
.      KC_DOT    KC.DOT
/      KC_SLASH  KC.SLASH
0      KC_0      KC.N0
1      KC_1      KC.N1
2      KC_2      KC.N2
3      KC_3      KC.N3
4      KC_4      KC.N4
5      KC_5      KC.N5
6      KC_6      KC.N6
7      KC_7      KC.N7
8      KC_8      KC.N8
9      KC_9      KC.N9
:      KC_COLN   KC.COLN  ?
;      KC_SCLN   KC.SCLN
<      KC_LT     KC.LT    ?
=      KC_EQL    KC.EQL
>      KC_GT     KC.GT    ?
?      KC_QUES   KC.QUES  ?
@      KC_AT     KC.AT
A      S(A)      KC.LSFT(A) 
B      S(B)      KC.LSFT(B)
C      S(C)      KC.LSFT(C)
D      S(D)      KC.LSFT(D)
E      S(E)      KC.LSFT(E)
F      S(F)      KC.LSFT(F)
G      S(G)      KC.LSFT(G)
H      S(H)      KC.LSFT(H)
I      S(I)      KC.LSFT(I)
J      S(J)      KC.LSFT(J)
K      S(K)      KC.LSFT(K)
L      S(L)      KC.LSFT(L)
M      S(M)      KC.LSFT(M)
N      S(N)      KC.LSFT(N)
O      S(O)      KC.LSFT(O)
P      S(P)      KC.LSFT(P)
Q      S(Q)      KC.LSFT(Q)
R      S(R)      KC.LSFT(R)
S      S(S)      KC.LSFT(S)
T      S(T)      KC.LSFT(T)
U      S(U)      KC.LSFT(U)
V      S(V)      KC.LSFT(V)
W      S(W)      KC.LSFT(W)
X      S(X)      KC.LSFT(X)
Y      S(Y)      KC.LSFT(Y)
Z      S(Z)      KC.LSFT(Z)
[      KC_LBRC   KC.LBRC
\      KC_BSLS   KC.BSLS
]      KC_RBRC   KC.RBRC
^      KC_CIRC   KC.CIRC
_      KC_UNDS   KC.UNDS
`      KC_GRV    KC.GRV
a      KC_A      KC.A
b      KC_B      KC.B
c      KC_C      KC.C
d      KC_D      KC.D
e      KC_E      KC.E
f      KC_F      KC.F
g      KC_G      KC.G
h      KC_H      KC.H
i      KC_I      KC.I
j      KC_J      KC.J
k      KC_K      KC.K
l      KC_L      KC.L
m      KC_M      KC.M
n      KC_N      KC.N
o      KC_O      KC.O
p      KC_P      KC.P
q      KC_Q      KC.Q
r      KC_R      KC.R
s      KC_S      KC.S
t      KC_T      KC.T
u      KC_U      KC.U
v      KC_V      KC.V
w      KC_W      KC.W
x      KC_X      KC.X
y      KC_Y      KC.Y
z      KC_Z      KC.Z
{      KC_LCBR   KC.LCBR
|      KC_PIPE   KC.PIPE
}      KC_RCBR   KC.RCBR
~      KC_TILDE  KC.TILDE

◌      KC_NO     KC.NO

⌃       KC_LCTL   KC.LCTL
⇧       KC_LSFT   KC.LSFT
⌥      KC_LOPT   KC.LOPT
OPT     KC_LOPT   KC.LOPT
⌘       KC_LCMD   KC.LCMD
CMD     KC_LCMD   KC.LCMD

⇪      CAPS_WORD   CAPS_WORD   
CAPS   CAPS_WORD   CAPS_WORD   

↵       KC_ENT   KC.ENT
RET     KC_ENT   KC.ENT
⎋      KC_ESC   KC.ESC
ESC     KC_ESC   KC.ESC
⌫      KC_BSPC   KC.BSPC
BS      KC_BSPC   KC.BSPC
⇥       KC_TAB   KC.TAB

HME  KC_HOME   KC.HOME
END  KC_END   KC.END
P↑   KC_PGUP   KC.PGUP
P↓   KC_PGDN   KC.PGDN
←    KC_RIGHT   KC.RIGHT
→    KC_LEFT   KC.LEFT
↓    KC_DOWN   KC.DOWN
↑    KC_UP   KC.UP


M₀   MO(0)   KC.MO(0)
M₁   MO(1)   KC.MO(1)
M₂   MO(2)   KC.MO(2)
M₃   MO(3)   KC.MO(3)
M₄   MO(4)   KC.MO(4)
M₅   MO(5)   KC.MO(5)
M₆   MO(6)   KC.MO(6)
M₇   MO(7)   KC.MO(7)
M₈   MO(8)   KC.MO(8)
M₉   MO(9)   KC.MO(9)

M0   MO(0)   KC.MO(0)
M1   MO(1)   KC.MO(1)
M2   MO(2)   KC.MO(2)
M3   MO(3)   KC.MO(3)
M4   MO(4)   KC.MO(4)
M5   MO(5)   KC.MO(5)
M6   MO(6)   KC.MO(6)
M7   MO(7)   KC.MO(7)
M8   MO(8)   KC.MO(8)
M9   MO(9)   KC.MO(9)


#+end_example




* Keymaps

#+name: planck_20221012
#+begin_example
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ESC  OPT  CMD   M1   ␣    ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    &    *    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    _    +    "    '    |
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    1    2    3    4    5    6    7    8    9    0    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌    ◌    ◌    M4   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    7    8    9    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    4    5    6    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    0    1    2    3    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_example

It's a pain in the ass to change a keymap all at once so I'm going to
attempt to do it a bit at a time. My strategy will be something like
this:

- [X] Move 0 in the numpad layer off of the mod row in anticipation of losing those keys
- [ ] Move the movement layer to the left space button, need to still consider that we use
      that to get to the numpad row so keep it working like before too
- [ ] Make a beep when I use the palm key for movement
- [ ] Since there's not much in the current symbol layer, move as many symbols as possible
      to the numpad layer and move the numpad layer over to M1. We will need to relocate:
      &    *    _    +    "
      And we might as well move those over to the symbol layer as soon as possible
      
At this point what we end up with is _ still being symmetrical with - but it's LWR-F
instead of LWR-J and in some ways this maintains the symmetry in that both keys use
the home index key above the layer key.

The two quotes are also symmetrical in that the single quote uses the right pinky
and the double uses the right pinky on the same layer.

We add another period to the numpad layer so we can do a single roll of N-B to do '0.'

#+name: planck (mark ii)
#+begin_src keymap
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ESC  OPT  CMD   M1   M3   ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    7    8    9    ◌    ◌
◌    "    &    *    _    ◌    +    4    5    6    '    |
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    1    2    3    4    5    6    7    8    9    0    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌    ◌    ◌    M1   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_src

- [ ] At this point we pretty much never use the number row on M2 so we migth as well remove
      those numbers. The right thumb now is pretty much only used for the symmetrical brackets
      and the:  -   =   \

#+name: planck (mark iii)
#+begin_example
⇥    q    w    e    r    t    y    u    i    o    p    BS
⌃    a    s    d    f    g    h    j    k    l    :    RET
⇧    z    x    c    v    b    n    m    ,    .    /    ;
M3  ESC  OPT  CMD   M1   M3   ␣    M2   ◌    ◌    ◌    ◌

~    !    @    #    $    %    ^    7    8    9    ◌    ◌
◌    "    &    *    _    ◌    +    4    5    6    '    |
◌    ◌    ◌    ◌    ◌    .    0    1    2    3    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

`    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    BS
◌    [    ]    (    )    ◌    ◌    -    =    ◌    ◌    \
◌    <    >    {    }    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    ◌    ◌    ◌    ◌    ◌    ◌    P↑   ↑    P↓   ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ←    ↓    →    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌   HME   ◌   END   ◌    ◌
◌    ◌    ◌    ◌    M1   ◌    ◌    ◌    ◌    ◌    ◌    ◌

◌    F1   F2   F3   F4   F5   F6   F7   F8   F9  F10   ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌    ◌
#+end_example


* Debouncing

Simple de-bouncing (take last three and confirm they are all equal)

The assumption is that the wait time between each period in
history is long enough for debouncing. If it isn't then we can
increase the maxlen of the history deque.

#+begin_src python
history = collections.Deque(maxlen=3)
def debounce(keys):
    history.append(keys)
    return [a == b == c for a, b, c in zip(*history)]
#+end_src



#+begin_src python
keys = bitstring()
for w in writers:
    w.value = True
    for r in readers:
        keys.append(r.value())
    w.value = False

# The keys that are currently on    
on = debounce(keys)

switched_off = last - on
switched_on = on - last
last = on



#+end_src

We make decisions as to what is happening based on discrete snapshots
in time of the global state. It can be thought of as a matrix where
the y axis is time and the x axis is the set of keys.

.▪.▪...▪.....
.▪....▪▪.....
.▪....▪▪.....
.▪....▪▪.....
......▪......
......▪......

Then our job is just pattern matching over that matrix, finding the
match with the highest priority.

When we use a set of keys during that window we also take claim to
them for that time period so other potential patterns don't match
if they aren't supposed to.

*** Normal Keypress

A keypress is a sequence of ones followed by a zero.


*** Combos

A combo is when two keys are pressed the same time. But we can be
loose with our definition of "same time", so in we can allow the
key-downs to start within 5 ticks and allow the key-ups to end at
any time after that. And we can have different behaviors depending
on which key-up event happens first.

Actually if we transpose the matrix to be time on the x and keys on
the y then I think we can use regexes really easily to do the
matching, yes? Actually, since it's just boolean values it's now
easy to use a bitstring for each key. If we store 64 values in our
time window, then a single 64 bit word can be compared with another
word. 64 events at 5ms per event is 320ms which I think is probably
good enough.

QMK uses 50ms as the default combo term, which would be 10 quanta in
our system. For example if Key A starts at time 0 and Key B starts at
time 8 and both of them are pressed for an additional 4 quanta then
we will match this as a combo event for the two of them. To prevent
further matches we mask out the two keys during this time period.

We need to also decide whether to fire the key event when the match
happens or whether we wait until one or both of the keys are lifted.

High-level overview:

1. Get the set of keys that have at least one down event recorded
   (i.e., they aren't just zeros).

2. Loop over each of the configured combos sorted in order of
   most keys in the combo first.

3. Determine if the keys overlap for the minimum amount. If the
   minimum amount is 10 quanta then we want to make sure there is a
   sequence of 10 on bits -- 11 1111 1111 (1024) -- in common. Can can
   shift, mask, and AND to determine if this is true.

4. TODO: Look for a series of ones in front of one of them that extends
   for too long?


* Utility Routines

#+begin_src python
def bits(bs):
    """Converts the handy '▪.' bitstring format into a list of 0s and 1s.    
    """
    B = {'▪': 1, '.': 0}
    return [B[b] for b in bs]


def key_press(key, context, action):
    """Returns True if the key in the context was pressed.

    Side-effects include clearing out this event from the context
    and firing the provided action.

    >>> c = [bits('...▪▪.', '....▪.')]
    >>> c
    [[0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0]]
    >>> key_press(0, c, lambda k: print(f'Pressed {k}'))
    Pressed 0
    >>> c
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0]]
    """
    pass

def key_down(key, context):
    """Returns True if the key in the context is being current held down.

    No side-effects.
    """
    pass

#+end_src


* Generate KMK firmware keymap list

#+name: generate_kmk_keymap
#+begin_src python :var src=planck_20221012 :var conversion_in=conversion :results pp
import re, json
conversion = {}
for s in conversion_in.split('\n')[1:]:
    if s:
        k, *vals = re.findall(r'\S+', s)
        conversion[k] = vals[1]

key = lambda k: conversion.get(k, f'GUIDOFART: {k}')
layer = lambda l: [key(k) for k in l.split()]

return [layer(l) for l in src.split('\n\n')]
#+end_src



* Keyboard definition (no keymap)

#+name: kb.py
#+begin_src python :tangle output/kb.py
import board

from kmk.kmk_keyboard import KMKKeyboard as _KMKKeyboard
from kmk.scanners import DiodeOrientation

class KMKKeyboard(_KMKKeyboard):
    col_pins = (
        board.GP6,  board.GP7,  board.GP8,  board.GP9,
        board.GP10, board.GP11, board.GP12, board.GP13,
        board.GP21, board.GP20, board.GP19, board.GP18,
    )

    row_pins = (board.GP2, board.GP3, board.GP4, board.GP5)
    
    diode_orientation = DiodeOrientation.COL2ROW
#+end_src

#+name: main.py
#+begin_src python :tangle output/main.py :noweb yes
import board
from kb import KMKKeyboard
from kmk.handlers.sequences import simple_key_sequence
from kmk.keys import KC
from kmk.modules.layers import Layers

keyboard = KMKKeyboard()
keyboard.debug_enabled = True
keyboard.modules.append(Layers())
keyboard.keymap = <<generate_kmk_keymap()>>

if __name__ == '__main__':
    keyboard.go()
#+end_src

First we define what we mean by single characters in our own format
(char space+ definition newline). Do this in a code space.

Then we define our keymaps in a nice grid using combinations of
those single characters seperated by whitespace.

Next we define our keyboard as a sequence of columns and rows
or just all of the keys and define how they relate to the grid
we used in our keymaps.

Finally we write the firmware that runs on the keyboard. It should be
specific to our keyboard. We are doing this "inside-out" as compared
to most software these days -- We are writing the firmware ourselves
using help from utility routines to make the code idiomatic. This is
contrasted with the more common approach of providing a framework or
library that you use by way of configuration.

* Single-character definitions


https://www.emacswiki.org/emacs/TabStopList

#+begin_example
char   qmk       kmk      zmk
␣      KC_SPC    KC.SPC   ?
!      KC_EXLM   KC.EXLM  ?
"      KC_DQUO   KC.DQUO  ?
#      KC_HASH   KC.HASH
$      KC_DLR    KC.DLR   ?
%      KC_PERC   KC.PERC  ?
&      KC_AMPR   KC.AMPR  ?
'      KC_QUOT   KC.QUOT
(      KC_LPRN   KC.LPRN  ?
)      KC_RPRN   KC.RPRN  ?
*      KC_ASTR   KC.ASTR  ?
+      KC_PLUS   KC.PLUS  ?
,      KC_COMMA  KC.COMMA
-      KC_MINUS  KC.MINUS
.      KC_DOT    KC.DOT
/      KC_SLASH  KC.SLASH
0      KC_0      KC.N0
1      KC_1      KC.N1
2      KC_2      KC.N2
3      KC_3      KC.N3
4      KC_4      KC.N4
5      KC_5      KC.N5
6      KC_6      KC.N6
7      KC_7      KC.N7
8      KC_8      KC.N8
9      KC_9      KC.N9
:      KC_COLN   KC.COLN  ?
;      KC_SCLN   KC.SCLN
<      KC_LT     KC.LT    ?
=      KC_EQL    KC.EQL
>      KC_GT     KC.GT    ?
?      KC_QUES   KC.QUES  ?
@      KC_AT     KC.AT
A      S(A)      KC.LSFT(A) 
B      S(B)      KC.LSFT(B)
C      S(C)      KC.LSFT(C)
D      S(D)      KC.LSFT(D)
E      S(E)      KC.LSFT(E)
F      S(F)      KC.LSFT(F)
G      S(G)      KC.LSFT(G)
H      S(H)      KC.LSFT(H)
I      S(I)      KC.LSFT(I)
J      S(J)      KC.LSFT(J)
K      S(K)      KC.LSFT(K)
L      S(L)      KC.LSFT(L)
M      S(M)      KC.LSFT(M)
N      S(N)      KC.LSFT(N)
O      S(O)      KC.LSFT(O)
P      S(P)      KC.LSFT(P)
Q      S(Q)      KC.LSFT(Q)
R      S(R)      KC.LSFT(R)
S      S(S)      KC.LSFT(S)
T      S(T)      KC.LSFT(T)
U      S(U)      KC.LSFT(U)
V      S(V)      KC.LSFT(V)
W      S(W)      KC.LSFT(W)
X      S(X)      KC.LSFT(X)
Y      S(Y)      KC.LSFT(Y)
Z      S(Z)      KC.LSFT(Z)
[      KC_LBRC   KC.LBRC
\      KC_BSLS   KC.BSLS
]      KC_RBRC   KC.RBRC
^      KC_CIRC   KC.CIRC
_      KC_UNDS   KC.UNDS
`      KC_GRV    KC.GRV
a      KC_A      KC.A
b      KC_B      KC.B
c      KC_C      KC.C
d      KC_D      KC.D
e      KC_E      KC.E
f      KC_F      KC.F
g      KC_G      KC.G
h      KC_H      KC.H
i      KC_I      KC.I
j      KC_J      KC.J
k      KC_K      KC.K
l      KC_L      KC.L
m      KC_M      KC.M
n      KC_N      KC.N
o      KC_O      KC.O
p      KC_P      KC.P
q      KC_Q      KC.Q
r      KC_R      KC.R
s      KC_S      KC.S
t      KC_T      KC.T
u      KC_U      KC.U
v      KC_V      KC.V
w      KC_W      KC.W
x      KC_X      KC.X
y      KC_Y      KC.Y
z      KC_Z      KC.Z
{      KC_LCBR   KC.LCBR
|      KC_PIPE   KC.PIPE
}      KC_RCBR   KC.RCBR
~      KC_TILDE  KC.TILDE

⌃       KC_LCTL
⇧       KC_LSFT
⌥      KC_LOPT
⌘      KC_LCMD

↵       KC_ENT
⎋      KC_ESC
⌫      KC_BSPC
⇥       KC_TAB

⇞    KC_PGUP
⇟    KC_PGDN
←    KC_RIGHT
→    KC_LEFT
↓    KC_DOWN
↑    KC_UP

⓪   MO(0)
①   MO(1)
②   MO(2)
③   MO(3)
④   MO(4)
⑤   MO(5)
⑥   MO(6)
⑦   MO(7)
⑧   MO(8)
⑨   MO(9)
⑩   MO(10)
⑪   MO(11)
⑫   MO(12)

#+end_example


* Keymaps


* Debouncing

Simple de-bouncing (take last three and confirm they are all equal)

The assumption is that the wait time between each period in
history is long enough for debouncing. If it isn't then we can
increase the maxlen of the history deque.

#+begin_src python
history = collections.Deque(maxlen=3)
def debounce(keys):
    history.append(keys)
    return [a == b == c for a, b, c in zip(*history)]
#+end_src



#+begin_src python
keys = bitstring()
for w in writers:
    w.value = True
    for r in readers:
        keys.append(r.value())
    w.value = False

# The keys that are currently on    
on = debounce(keys)

switched_off = last - on
switched_on = on - last
last = on



#+end_src

We make decisions as to what is happening based on discrete snapshots
in time of the global state. It can be thought of as a matrix where
the y axis is time and the x axis is the set of keys.

.▪.▪...▪.....
.▪....▪▪.....
.▪....▪▪.....
.▪....▪▪.....
......▪......
......▪......

Then our job is just pattern matching over that matrix, finding the
match with the highest priority.

When we use a set of keys during that window we also take claim to
them for that time period so other potential patterns don't match
if they aren't supposed to.

*** Normal Keypress

A keypress is a sequence of ones followed by a zero.


*** Combos

A combo is when two keys are pressed the same time. But we can be
loose with our definition of "same time", so in we can allow the
key-downs to start within 5 ticks and allow the key-ups to end at
any time after that. And we can have different behaviors depending
on which key-up event happens first.

Actually if we transpose the matrix to be time on the x and keys on
the y then I think we can use regexes really easily to do the
matching, yes? Actually, since it's just boolean values it's now
easy to use a bitstring for each key. If we store 64 values in our
time window, then a single 64 bit word can be compared with another
word. 64 events at 5ms per event is 320ms which I think is probably
good enough.

QMK uses 50ms as the default combo term, which would be 10 quanta in
our system. For example if Key A starts at time 0 and Key B starts at
time 8 and both of them are pressed for an additional 4 quanta then
we will match this as a combo event for the two of them. To prevent
further matches we mask out the two keys during this time period.

We need to also decide whether to fire the key event when the match
happens or whether we wait until one or both of the keys are lifted.

High-level overview:

1. Get the set of keys that have at least one down event recorded
   (i.e., they aren't just zeros).

2. Loop over each of the configured combos sorted in order of
   most keys in the combo first.

3. Determine if the keys overlap for the minimum amount. If the
   minimum amount is 10 quanta then we want to make sure there is a
   sequence of 10 on bits -- 11 1111 1111 (1024) -- in common. Can can
   shift, mask, and AND to determine if this is true.

4. TODO: Look for a series of ones in front of one of them that extends
   for too long?

* Utility Routines

#+begin_src python
def bits(bs):
    """Converts the handy '▪.' bitstring format into a list of 0s and 1s.    
    """
    B = {'▪': 1, '.': 0}
    return [B[b] for b in bs]


def key_press(key, context, action):
    """Returns True if the key in the context was pressed.

    Side-effects include clearing out this event from the context
    and firing the provided action.

    >>> c = [bits('...▪▪.', '....▪.')]
    >>> c
    [[0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0]]
    >>> key_press(0, c, lambda k: print(f'Pressed {k}'))
    Pressed 0
    >>> c
    [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0]]
    """
    pass

def key_down(key, context):
    """Returns True if the key in the context is being current held down.

    No side-effects.
    """
    pass

    
#+end_src





